#pragma kernel Step
#pragma kernel Solve
#pragma kernel FixOne
#pragma kernel UnfixOne
#pragma kernel Gravity
#pragma kernel AdjustCollisions

#define MAX_COLLISIONS 16

#define THREAD [numthreads(8, 1, 1)]
#define DISCARD_NODE if((int)id.x >= _NodesCount) return;
#define DISCARD_EDGE if((int)id.x >= _EdgesCount) return;

struct Node
{
	float3 position;
	float3 prev;
	float decay;
	bool stable;
	uint collisionIndexes;
};

struct Edge
{
	int a;
	int b;
	float length;
};

struct CollisionInfo
{
	int id;
	int type;
	float3 position;
	float3 size;
	float3 scale;
	float4x4 wtl;
	float4x4 ltw;
	int numCollisions;
};

StructuredBuffer<Node> _NodesRead;
RWStructuredBuffer<Node> _Nodes;
RWStructuredBuffer<Edge> _Edges;
StructuredBuffer<CollisionInfo> _Collisions;
int _NodesCount, _EdgesCount, _CollisionsCount;
float _DT;

float _Decay;

int _FixedID;
float3 _FixedPoint;

float3 _Gravity;
float _NodeRadius;

float3 _DirectionMultiply;

THREAD
void Step(uint3 id : SV_DispatchThreadID)
{
	DISCARD_NODE
	
	Node n = _Nodes[id.x];
	
	float3 v = (n.position - n.prev) * _DirectionMultiply;
	float3 next = n.position + v * n.decay * _Decay;
	n.prev = n.position;
	n.position = next;
	
	_Nodes[id.x] = n;
}

float3 compute_delta(Edge e)
{
	Node a = _NodesRead[e.a];
	Node b = _NodesRead[e.b];
	float3 delta = a.position - b.position;
	float current = length(delta);
	float f = (current - e.length) / current;
	if (isnan(f) || isinf(f))
	{
		return (0).xxx;
	}
	return f * delta * 0.5;
}

THREAD
void Solve(uint3 id : SV_DispatchThreadID)
{
	DISCARD_NODE
	
	int idx = id.x;
	Node n = _NodesRead[idx];
	
	if (!n.stable)
	{
		for (int i = 0; i < _EdgesCount; i++)
		{
			Edge e = _Edges[i];
			if (e.a == idx)
			{
				n.position -= (compute_delta(e) * _DirectionMultiply);
			}
			else if (e.b == idx)
			{
				n.position += (compute_delta(e) * _DirectionMultiply);
			}
		}
	}
	
	_Nodes[idx] = n;
}

THREAD
void FixOne(uint3 id : SV_DispatchThreadID)
{
	DISCARD_NODE
	
	int idx = id.x;
	Node n = _Nodes[idx];
	bool stable = idx == _FixedID;
	n.position = lerp(n.position, _FixedPoint, stable);
	n.stable = n.stable || stable;
	_Nodes[idx] = n;
}

THREAD
void UnfixOne(uint3 id : SV_DispatchThreadID)
{
	DISCARD_NODE
	
	int idx = id.x;
	Node n = _Nodes[idx];
	bool stable = idx == _FixedID;
	if (stable)
	{
		n.stable = false;
	}
	_Nodes[idx] = n;
}

THREAD
void Gravity(uint3 id : SV_DispatchThreadID)
{
	DISCARD_NODE
	
	int idx = id.x;
	Node n = _Nodes[idx];
	float3 next = n.position + (_Gravity * _DirectionMultiply) * _DT * _DT * (!n.stable);
	n.position = next;
	_Nodes[idx] = n;
}

bool GetBit(uint mask, int bit)
{
	uint tempmask = mask;
	return ((tempmask >> bit) & 1) == 1;
}

uint SetBit(uint mask, int bit, bool set)
{
	uint tempmask = mask;
	if (set)
	{
		tempmask |= (1 << bit);
	}
	else
	{
		tempmask &= ~(1 << bit);
	}
	return tempmask;
}

float3 PosAfterCollision(CollisionInfo ci, Node node)
{
	switch (ci.type)
	{
		case (0): // None
			return node.position;
			break;
		case (1): // Sphere
			float colliderRadius = ci.size.x * max(max(ci.scale.x, ci.scale.y), ci.scale.z);
			float totalRadius = colliderRadius + _NodeRadius;
			float distance = length(ci.position - node.position);
					
			if (distance - totalRadius > 0)
			{
				return node.position;
			}
			float3 dir = normalize(node.position - ci.position) * _DirectionMultiply;
				
			return ci.position + dir * totalRadius;
			break;
		case (2): // Box
			float3 localPoint = mul(ci.wtl, float4(node.position, 1)).xyz;
			float3 halfe = (ci.size + _NodeRadius) * 0.5f;
			//float3 halfe = ci.size * 0.5f + node.radius;
			//float3 sclar = ci.scale;
		
			bool inside = (abs(localPoint.x) < halfe.x) &&
						  (abs(localPoint.y) < halfe.y) &&
						  (abs(localPoint.z) < halfe.z);
			
			if (!inside)
			{
				return node.position;
			}
		
			float3 pen = halfe - abs(localPoint);

			int axis = 0;
			float minPen = pen.x;
			if (pen.y < minPen)
			{
				axis = 1;
				minPen = pen.y;
			}
			if (pen.z < minPen)
			{
				axis = 2;
				minPen = pen.z;
			}

			if (axis == 0)
			{
				localPoint.x += pen.x * sign(localPoint.x) * _DirectionMultiply.x;
			}
			else if (axis == 1)
			{
				localPoint.y += pen.y * sign(localPoint.y) * _DirectionMultiply.y;
			}
			else
			{
				localPoint.z += pen.z * sign(localPoint.z) * _DirectionMultiply.z;
			}
		
			//if ((pen.x * scalar.x < pen.y * scalar.y) && (pen.x * scalar.x < pen.z * scalar.z))
			//{
			//	localPoint.x = halfe.x * sign(localPoint.x);
			//}
			//else if (pen.y * scalar.y < pen.z * scalar.z)
			//{
			//	localPoint.y = halfe.y * sign(localPoint.y);
			//}
			//else
			//{
			//	localPoint.z = halfe.z * sign(localPoint.z);
			//}
				
			return mul(ci.ltw, float4(localPoint, 1)).xyz;
			break;
	}
	return node.position;
}

THREAD
void AdjustCollisions(uint3 id : SV_DispatchThreadID)
{
	DISCARD_NODE
	
	for (int i = 0; i < MAX_COLLISIONS; i++)
	{
		if (i >= _CollisionsCount)
		{
			break;
		}
		
		CollisionInfo ci = _Collisions[i];
		Node n = _Nodes[id.x];
		
		if (n.stable)
		{
			continue;
		}
		
		if (!GetBit(n.collisionIndexes, i))
		{
			continue;
		}
		
		float3 next = PosAfterCollision(ci, n);
		//n.prev = n.position;
		//n.position = lerp(n.position, next, 0.5);
		n.position = next;
		//n.collisionIndexes = SetBit(n.collisionIndexes, i, false);
		_Nodes[id.x] = n;
	}
}
